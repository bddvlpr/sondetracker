/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/amateur/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Amateur Radiosonde Telemetry Data
         * @description Use this to get the current state of all the radiosondes then use the realtime API to access streaming data. Do not regularly poll this endpoint, it is rate limited.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description How far back in time to receive data from. A shorter time period will result is higher time resolution data. */
                    duration?: "0" | "15s" | "1m" | "30m" | "1h" | "3h" | "6h" | "1d" | "3d";
                    /** @description Specific callsign to query (if wanted). Requests for data for a single sonde will return the highest time resolution data available. */
                    payload_callsign?: string;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by serial number of a dictionary of times with SondeHub Telemetry values */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["amateur_query_results_format"];
                    };
                };
            };
        };
        /** Upload Radiosonde Telemetry to Sondehub amateur database. */
        put: {
            parameters: {
                query?: never;
                header?: {
                    /** @description The software and version performing the telemetry upload, eg:  `autorx-1.4.1-beta5` */
                    "User-Agent"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody: components["requestBodies"]["input_amateur_payloads"];
            responses: {
                /** @description Telemetry Saved into Database Successfuly */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Other Server error (including malformed data submissions) */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/amateur/telemetry/{payload_callsign}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Amateur Radiosonde Telemetry Data
         * @description Use this to get the current state of all the radiosondes then use the realtime API to access streaming data. Do not regularly poll this endpoint, it is rate limited.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description How far back to search in seconds. Defaults to 24hrs */
                    last?: number;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                    /** @description Valid options are csv, kml or json */
                    format?: string;
                };
                header?: never;
                path: {
                    /** @description Specific callsign to query (if wanted). Requests for data for a single sonde will return the highest time resolution data available. */
                    payload_callsign: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a list of all data received */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["amateur_query_full_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sondes/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Radiosonde Telemetry Data
         * @description Use this to get the current state of all the radiosondes then use the realtime API to access streaming data. Do not regularly poll this endpoint, it is rate limited.
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description How far back in time to receive data from. A shorter time period will result is higher time resolution data. */
                    duration?: "0" | "15s" | "1m" | "30m" | "1h" | "3h" | "6h" | "1d" | "3d";
                    /** @description Specific serial number to query (if wanted). Requests for data for a single sonde will return the highest time resolution data available. */
                    serial?: string;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by serial number of a dictionary of times with SondeHub Telemetry values */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["sonde_query_results_format"];
                    };
                };
            };
        };
        /** Upload Radiosonde Telemetry to Sondehub database. */
        put: {
            parameters: {
                query?: never;
                header: {
                    /** @description <day-name>, <day> <month> <year> <hour>:<minute>:<second> UTC as per RFC7231. This is used to calculate receiver time offset for correcting clients that have the incorrect time. */
                    Date: string;
                    /** @description The software and version performing the telemetry upload, eg:  `autorx-1.4.1-beta5` */
                    "User-Agent"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody: components["requestBodies"]["input_payloads"];
            responses: {
                /** @description Telemetry Saved into Database Successfuly */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Other Server error (including malformed data submissions) */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/amateur": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Request latest amateur payload data indexed by serial number, with options for position/distance based-filtering. */
        get: {
            parameters: {
                query?: {
                    /** @description Latitude - if specified, lon and distance are required. Eg: -34.9285 */
                    lat?: number;
                    /** @description Longitude - if specified, lat and distance are required Eg:  138.6007 */
                    lon?: number;
                    /** @description Distance in meters - if specified, lat and lon are required */
                    distance?: number;
                    /** @description How far back to search in seconds. Defaults to 24hrs */
                    last?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by serial number of a dictionary of times with SondeHub Telemetry values */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["amateur_telm_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sondes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Request latest sonde data indexed by serial number, with options for position/distance based-filtering. */
        get: {
            parameters: {
                query?: {
                    /** @description Latitude - if specified, lon and distance are required. Eg: -34.9285 */
                    lat?: number;
                    /** @description Longitude - if specified, lat and distance are required Eg:  138.6007 */
                    lon?: number;
                    /** @description Distance in meters - if specified, lat and lon are required */
                    distance?: number;
                    /** @description How far back to search in seconds. Defaults to 24hrs */
                    last?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by serial number of a dictionary of times with SondeHub Telemetry values */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["sonde_telm_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sondes/site/{site}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Request latest sonde data indexed by serial number based on site ID */
        get: {
            parameters: {
                query?: {
                    /** @description How far back to search in seconds. Defaults to 24hrs. Limited to 7 days */
                    last?: number;
                };
                header?: never;
                path: {
                    /** @description Site number of the radiosonde to request data for (see /sites endpoint) */
                    site: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by serial number of a dictionary of times with SondeHub Telemetry values */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["sonde_telm_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sonde/{serial}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request telemetry data for an individual radiosonde
         * @description Use this to request all available telemetry data for an individual radiosonde, specified by serial number.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Serial number of the radiosonde to request data for. e.g. S1130567 */
                    serial: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a time-sorted array of SondeHub Telemetry objects. If no data for the requested serial number is available, the array will be empty. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["telemetry_format"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/amateur/listeners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Allows a station to upload their station information to the SondeHub database, for display on the SondeHub Tracker map. This endpoint can also be used to upload chase-car positions by setting the "mobile" setting to True */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["listener"];
                };
            };
            responses: {
                /** @description Station Position successfully uploaded. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/amateur/listeners/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Listener Telemetry Data
         * @description Use this to get the current listener (chase car / station) telemetry
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description How far back in time to receive data from. A shorter time period will result is higher time resolution data. */
                    duration?: "3h" | "6h" | "1d" | "3d";
                    /** @description Specific callsign number to query (if wanted). Requests for data for a single uploader will return the highest time resolution data available. */
                    uploader_callsign?: string;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by uploader_callsign of a dictionary of times with listener data. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["listener_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/listeners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Allows a station to upload their station information to the SondeHub database, for display on the SondeHub Tracker map. This endpoint can also be used to upload chase-car positions by setting the "mobile" setting to True */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["listener"];
                };
            };
            responses: {
                /** @description Station Position successfully uploaded. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/listeners/telemetry": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Listener Telemetry Data
         * @description Use this to get the current listener (chase car / station) telemetry
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description How far back in time to receive data from. A shorter time period will result is higher time resolution data. */
                    duration?: "3h" | "6h" | "1d" | "3d";
                    /** @description Specific callsign number to query (if wanted). Requests for data for a single uploader will return the highest time resolution data available. */
                    uploader_callsign?: string;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary keyed by uploader_callsign of a dictionary of times with listener data. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["listener_results_format"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/listeners/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Basic version stats
         * @description Use this to get stats on how many users are using specific software
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a dictionary of softwares and versions */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["listener_stats"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sondes/websocket": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a presigned URL for use in connecting to the MQTT websocket endpoint. */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A presigned URL for connecting to the websocket MQTT feed. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/predictions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Radiosonde landing predictions */
        get: {
            parameters: {
                query?: {
                    /** @description If provided, filters predictions to a single provided serial number. Should be provided, but left blank if no filtering is required. */
                    vehicles?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Prediction results */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["predictions"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/predictions/reverse": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Radiosonde launch site predictions */
        get: {
            parameters: {
                query?: {
                    /** @description If provided, filters predictions to a single provided serial number. Should be provided, but left blank if no filtering is required. */
                    vehicles?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Prediction results */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["predictions"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recovered": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Recovery Data
         * @description Use this to get the recovery data
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description radiosonde serial number (or multiple serial numbers separated by a comma) to filter on. If none provided all serials will be presented. */
                    serial?: string;
                    /** @description Latitude - if specified, lon and distance are required. Eg: -34.9285 */
                    lat?: number;
                    /** @description Longitude - if specified, lat and distance are required Eg:  138.6007 */
                    lon?: number;
                    /** @description Distance in meters - if specified, lat and lon are required */
                    distance?: number;
                    /** @description How far back to search in seconds. Defaults to 3 days. Set to 0 for all */
                    last?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a list of recovery objects */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["recovery_results_format"];
                    };
                };
            };
        };
        /** Adds a recovery object to the SondeHub database to indicate if a radiosonde was recovered */
        put: {
            parameters: {
                query?: never;
                header: {
                    /** @description <day-name>, <day> <month> <year> <hour>:<minute>:<second> UTC as per RFC7231. This is used to calculate receiver time offset for correcting clients that have the incorrect time. */
                    Date: string;
                    /** @description The software and version performing the telemetry upload, eg:  `autorx-1.4.1-beta5` */
                    "User-Agent"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["recovery_object"];
                };
            };
            responses: {
                /** @description Recovery logged */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Other Server error (including malformed data submissions) */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/recovered/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request Recovery Stats
         * @description Use this to get the recovery stats
         *
         */
        get: {
            parameters: {
                query?: {
                    /** @description Latitude - if specified, lon and distance are required. Eg: -34.9285 */
                    lat?: number;
                    /** @description Longitude - if specified, lat and distance are required Eg:  138.6007 */
                    lon?: number;
                    /** @description Distance in meters - if specified, lat and lon are required */
                    distance?: number;
                    /** @description How far back to search in seconds. Defaults to foreverl */
                    duration?: number;
                    /** @description End time to query as an ISO-8601 time string. Defaults to now. Example: `2021-02-02T11:27:38.634Z` */
                    datetime?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns a list of recovery objects */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["recovery_stats"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Radiosonde launch sites */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Prediction results */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            [key: string]: components["schemas"]["site"];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description SondeHub amateur balloon telemetry format */
        amateur_telemetry_format: {
            /** @description If this field is set then the payload will not be uploaded to the database. This is useful for development and testing.
             *      */
            dev?: string;
            /** @description Name of the decoding software
             *     e.g. 'horusgui'
             *      */
            software_name: string;
            /** @description Version of the decoding software
             *     e.g. '1.4.0', '20210115'
             *      */
            software_version: string;
            /** @description Callsign of the uploader
             *     Arbitrary string. Uploader position information and other metadata will be handled separately, but will need to match this callsign to enable calculation of listener statistics.
             *      */
            uploader_callsign: string;
            /**
             * Format: date-time
             * @description The time the telemetry packet was received. UTC time in YYYY-MM-DDTHH:MM:SS.SSSSSSZ format.
             *
             */
            time_received: string;
            /** @description Callsign for the payload
             *      */
            payload_callsign: string;
            /**
             * Format: date-time
             * @description Date/Time from the sonde's GPS, provided in YYYY-MM-DDTHH:MM:SS.SSSSSSZ format
             *     Some sondes (e.g. iMet, LMS6) do not provide the date portion of the timestamp. In this situation, the date portion should be added on by the receiver. An example of how to handle this problem is [available here](https://github.com/projecthorus/radiosonde_auto_rx/blob/master/auto_rx/autorx/sonde_specific.py#L13).
             *
             */
            datetime: string;
            /**
             * Format: double
             * @description Latitude (decimal degrees)
             */
            lat: number;
            /**
             * Format: double
             * @description Longitude (decimal degrees)
             */
            lon: number;
            /**
             * Format: double
             * @description Altitude (metres)
             */
            alt: number;
            /**
             * Format: float
             * @description Transmit frequency of the radiosonde in MHz.
             */
            frequency?: number;
            /**
             * Format: float
             * @description Measured Temperature (deg C)
             */
            temp?: number;
            /**
             * Format: float
             * @description Measured Relative Humidity (%)
             */
            humidity?: number;
            /**
             * Format: float
             * @description Horizontal Velocity (m/s)
             */
            vel_h?: number;
            /**
             * Format: float
             * @description Horizontal Velocity (m/s)
             */
            vel_v?: number;
            /**
             * Format: float
             * @description Measured Pressure (hPa)
             */
            pressure?: number;
            /**
             * Format: float
             * @description Heading (degrees True)
             */
            heading?: number;
            /**
             * Format: float
             * @description Battery Voltage (volts)
             */
            batt?: number;
            /**
             * Format: integer
             * @description Number of SVs used in position solution
             */
            sats?: number;
            /**
             * Format: float
             * @description Signal-to-Noise ratio of the received signal, in dB
             */
            snr?: number;
            /**
             * Format: float
             * @description Received-Signal-Strength-Indication of the radiosonde signal, nominally in dBm
             */
            rssi?: number;
            /** @description Station position, as a list [lat, lon, alt]. */
            uploader_position?: number[];
            /** @description Station antenna/receiver information, free-text string. */
            uploader_antenna?: string;
            /** @description This field is usually set by the server and usually does not need to be set when uploading. This controls if the data should be shown in default dashboards and the website. */
            telemetry_hidden?: boolean;
            /** @description Set this to true if uploading data in the past */
            historical?: boolean;
            /**
             * Format: date-time
             * @description Set by the server to indicate the servers received time. Not not set this when uploading.
             */
            upload_time: string;
        };
        amateur_query_results_format: {
            serial?: {
                [key: string]: components["schemas"]["amateur_telemetry_format"];
            };
        };
        amateur_query_full_results_format: components["schemas"]["amateur_telemetry_format"][];
        /** @description SondeHub telemetry format */
        telemetry_format: {
            /** @description If this field is set then the payload will not be uploaded to the database. This is useful for development and testing.
             *      */
            dev?: string;
            /** @description Name of the decoding software
             *     e.g. 'radiosonde_auto_rx', 'dxlAPRS', 'RS41Tracker', 'mySondy'
             *      */
            software_name: string;
            /** @description Version of the decoding software
             *     e.g. '1.4.0', '20210115'
             *      */
            software_version: string;
            /** @description Callsign of the uploader
             *     Arbitrary string. Uploader position information and other metadata will be handled separately, but will need to match this callsign to enable calculation of listener statistics.
             *      */
            uploader_callsign: string;
            /**
             * Format: date-time
             * @description The time the telemetry packet was received. UTC time in YYYY-MM-DDTHH:MM:SS.SSSSSSZ format.
             *
             */
            time_received: string;
            /**
             * @description Radiosonde Manufacturer, as determined from the transmit modulation and high-level packet format.
             * @enum {string}
             */
            manufacturer: "Vaisala" | "Graw" | "Meteomodem" | "Intermet Systems" | "Lockheed Martin" | "Meteo-Radiy" | "Meteosis" | "Meisei";
            /**
             * @description The high-level radiosonde model, as can be determined just from the transmit modulation and high-level packet format.
             * @enum {string}
             */
            type: "RS41" | "DFM" | "M10" | "M20" | "iMet-4" | "iMet-50" | "iMet-54" | "LMS6-400" | "LMS6-1680" | "MRZ" | "MTS01" | "iMS-100" | "RS-11G";
            /** @description Radiosonde Serial Number. Where possible this should be in the format which matches the sticker/label on the radiosonde itself
             *     iMet-1/iMet-4 sondes do not provide a serial number, and so auto_rx [generates](https://github.com/projecthorus/radiosonde_auto_rx/wiki/Model-Specific-Notes#intermet-imet-1--imet-4) a serial number based on launch time and transmit frequency. DFM sondes do not regularly transmit their serial number, and so data from these sondes should not be uploaded before the serial number is known.
             *      */
            serial: string;
            /**
             * Format: integer
             * @description Frame Number, ideally unique over the entire flight. Should be taken from the telemetry. For some radiosondes (DFM, M10, M20), the datetime (converted to a unix time) is used instead of the provided frame number.
             *
             */
            frame: number;
            /**
             * Format: date-time
             * @description Date/Time from the sonde's GPS, provided in YYYY-MM-DDTHH:MM:SS.SSSSSSZ format
             *     Some sondes (e.g. iMet, LMS6) do not provide the date portion of the timestamp. In this situation, the date portion should be added on by the receiver. An example of how to handle this problem is [available here](https://github.com/projecthorus/radiosonde_auto_rx/blob/master/auto_rx/autorx/sonde_specific.py#L13).
             *
             */
            datetime: string;
            /**
             * Format: double
             * @description Latitude (decimal degrees)
             */
            lat: number;
            /**
             * Format: double
             * @description Longitude (decimal degrees)
             */
            lon: number;
            /**
             * Format: double
             * @description Altitude (metres)
             */
            alt: number;
            /**
             * @description Detailed Radiosonde Model Type, as determined through analysis of the telemetry.
             * @enum {string}
             */
            subtype?: "RS41-SG" | "RS41-SGP" | "RS41-SGM" | "DFM06" | "DFM09" | "DFM09P" | "DFM17" | "M10" | "M20" | "MRZ-H1";
            /**
             * Format: float
             * @description Transmit frequency of the radiosonde in MHz.
             */
            frequency?: number;
            /**
             * Format: float
             * @description Measured Temperature (deg C)
             */
            temp?: number;
            /**
             * Format: float
             * @description Measured Relative Humidity (%)
             */
            humidity?: number;
            /**
             * Format: float
             * @description Horizontal Velocity (m/s)
             */
            vel_h?: number;
            /**
             * Format: float
             * @description Horizontal Velocity (m/s)
             */
            vel_v?: number;
            /**
             * Format: float
             * @description Measured Pressure (hPa)
             */
            pressure?: number;
            /**
             * Format: float
             * @description Heading (degrees True)
             */
            heading?: number;
            /**
             * Format: float
             * @description Battery Voltage (volts)
             */
            batt?: number;
            /**
             * Format: integer
             * @description Number of SVs used in position solution
             */
            sats?: number;
            /**
             * Format: ascii hex
             * @description Auxiliary Data (e.g Ozone data) as a hexadecimal string.
             */
            xdata?: string;
            /**
             * Format: float
             * @description Signal-to-Noise ratio of the received signal, in dB
             */
            snr?: number;
            /**
             * Format: float
             * @description Received-Signal-Strength-Indication of the radiosonde signal, nominally in dBm
             */
            rssi?: number;
            /** @description Station position, as a list [lat, lon, alt]. */
            uploader_position?: number[];
            /** @description Station antenna/receiver information, free-text string. */
            uploader_antenna?: string;
        };
        sonde_query_results_format: {
            [key: string]: {
                [key: string]: components["schemas"]["telemetry_format"];
            };
        };
        amateur_telm_results_format: {
            serial?: components["schemas"]["amateur_telemetry_format"];
        };
        sonde_telm_results_format: {
            serial?: components["schemas"]["telemetry_format"];
        };
        listener: {
            /** @description Software Name, # e.g. radiosonde_auto_rx */
            software_name?: string;
            /** @description Software version number,  e.g. 1.5.1 */
            software_version?: string;
            /** @description Station callsign, # e.g. CHANGEME_AUTO_RX */
            uploader_callsign?: string;
            /** @description Station position, as a list [lat, lon, alt] Note: This may be set to null, which will result in the station position not appearing on the map. */
            uploader_position?: number[];
            /** @description Uploader's radio description */
            uploader_radio?: string;
            /** @description Uploader's antenna description */
            uploader_antenna?: string;
            /** @description Optional contact e-mail, to assist SondeHub admins in resolving faults. e.g. user_contact_email@host.com */
            uploader_contact_email?: string;
            /** @description Indicates that the station is mobile, and should appear as a chase car on the tracker map. Set to false if this is a fixed station. */
            mobile?: boolean;
        };
        listener_results_format: {
            [key: string]: {
                [key: string]: components["schemas"]["listener"];
            };
        };
        /** @example {
         *       "radiosonde_auto_rx": {
         *         "telemetry_count": 500,
         *         "unique_callsigns": 10,
         *         "versions": {
         *           "1.5.8": {
         *             "telemetry_count": 25463802,
         *             "unique_callsigns": 327
         *           }
         *         }
         *       }
         *     } */
        listener_stats: {
            [key: string]: Record<string, never>;
        };
        predictions: {
            /** @description callsign / serial of the radiosonde */
            vehicle?: string;
            /** Format: date-time */
            time?: string;
            latitude?: number;
            longitude?: number;
            altitude?: number;
            ascent_rate?: number;
            descent_rate?: number;
            burst_altitude?: number;
            landed?: Record<string, never>;
            /** @description This is the json output from the Tāwhirimātea predictor http://tawhiri.cusf.co.uk */
            data?: string;
        }[];
        recovery_object: {
            /**
             * Format: date-time
             * @description Time that the radiosonde was recovered
             */
            datetime?: string;
            /** @description Serial number of the radiosonde */
            serial: string;
            /**
             * Format: double
             * @description Latitude (decimal degrees) of the recovery location
             */
            lat: number;
            /**
             * Format: double
             * @description Longitude (decimal degrees) of the recovery location
             */
            lon: number;
            /**
             * Format: double
             * @description Altitude (metres) of the recovery location
             */
            alt: number;
            /** @description was this recovery attempt was successful */
            recovered: boolean;
            /** @description callsign or name of the person who recovered the sonde */
            recovered_by: string;
            /** @description Description of the recovery effort */
            description?: string;
        };
        recovery_results_format: components["schemas"]["recovery_object"][];
        recovery_stats: {
            /** @description Total number of serial numbers that have had at least one attempt */
            total: number;
            /** @description Total number of serial numbers that have been recovered */
            recovered: number;
            /** @description Total number of serial numbers that have a failed recovered attempt */
            failed: number;
            /** @description Total number of unique recovery names */
            chaser_count: number;
            /** @description chaser name : number of attempted recoveries */
            top_chasers: Record<string, never>;
        };
        /** @description Site */
        site: {
            /** @description Lat Lng */
            position?: number[];
            /** @description Station ID number */
            station?: string;
            /** @description Name of the station */
            station_name?: string;
            /**
             * Format: double
             * @description Altitude of the station in meters
             */
            alt?: number;
            /** @description A list of strings where each string represents a UTC launch schedule created in the following format:
             *     0:00:00 (day:hour:minute) When day is set to 0 it means that the following launch time occurs every day When day is set to 1-7 it means the following launch occurs weekly on that day (Monday - Sunday)
             *     Hour is expressed in 24 hour time and we stick with 3 hour windows to keep things simple so 03, 06, 09, 12, 15, 18, 21, 24
             *     Minutes can be any value between 0 and 60 but we always leave this value at 00 (in the tracker we subtract 45 minutes from the time to generate predictions).
             *      */
            times?: string[];
            /** @description The radiosonde types for this site: Supported : "07":"iMet-1", "11":"LMS6-403", "13":"RS92", "14":"RS92", "17":"DFM-09", "18":"DFM-06", "19":"MRZ-N1", "22":"RS-11G", "23":"RS41", "24":"RS41", "34":"iMet-4", "35":"iMS-100", "41":"RS41", "42":"RS41", "52":"RS92-NGP", "54":"DFM-17", "62":"MRZ-3MK", "63":"M20", "77":"M10", "82":"LMS6-1680", "84":"iMet-54" Unsupported : "15":"PAZA-12M", "16":"PAZA-22", "20":"MK3", "21":"1524LA LORAN-C/GL5000", "26":"SRS-C34", "27":"AVK-MRZ", "28":"AVK–AK2-02", "29":"MARZ2-2", "30":"RS2-80", "33":"GTS1-2/GFE(L)", "45":"CF-06", "58":"AVK-BAR", "59":"M2K2-R", "68":"AVK-RZM-2", "69":"MARL-A/Vektor-M-RZM-2", "73":"MARL-A", "78":"RS90", "80":"RS92", "88":"MARL-A/Vektor-M-MRZ", "89":"MARL-A/Vektor-M-BAR", "97":"iMet-2", "99":"iMet-2"
             *     They can either be provided as a single list of strings containing one or more codes: "rs_types": ["41", "07"]
             *     If the sondes always transmit on the same known frequency this can also be provided by having each code within a nested list containing the code and frequency: "rs_types": [["41", "404.300"], ["07", "404.200"]]
             *      */
            rs_types?: string[];
            /**
             * Format: double
             * @description Average burst altitude for this site. Used for predictions
             */
            burst_altitude?: number;
            /**
             * Format: double
             * @description Typical ascent rate in m/s
             */
            ascent_rate?: number;
            /**
             * Format: double
             * @description Typical descent rate in m/s
             */
            descent_rate?: number;
            /**
             * Format: double
             * @description Standard deviation from analytics of burst
             */
            burst_std?: number;
            /**
             * Format: double
             * @description Standard deviation from analytics of descent rate
             */
            descent_std?: number;
            /**
             * Format: double
             * @description Number of samples used to calculate the burst altitude
             */
            burst_samples?: number;
            /**
             * Format: double
             * @description Number of samples used to calculate the descent rate
             */
            descent_samples?: number;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: {
        input_amateur_payloads: {
            content: {
                "*/*": components["schemas"]["amateur_telemetry_format"][];
            };
        };
        input_payloads: {
            content: {
                "*/*": components["schemas"]["telemetry_format"][];
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
